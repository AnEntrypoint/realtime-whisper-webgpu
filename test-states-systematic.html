<!DOCTYPE html>
<html>
<head>
    <title>Systematic State Testing</title>
    <style>
        body { font-family: monospace; margin: 20px; }
        pre { background: #f5f5f5; padding: 15px; overflow-x: auto; max-height: 600px; overflow-y: auto; }
        .success { color: green; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .info { color: blue; }
        button { padding: 10px 20px; font-size: 14px; cursor: pointer; }
    </style>
</head>
<body>
    <h1>Systematic State Shape Testing</h1>
    <button onclick="runTest()">Start Testing</button>
    <pre id="output"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = ;
        const output = document.getElementById('output');

        let results = {
            working: [],
            failing: []
        };

        function log(msg, type = 'info') {
            const span = document.createElement('div');
            span.textContent = msg;
            if (type === 'success') span.className = 'success';
            else if (type === 'error') span.className = 'error';
            else if (type === 'info') span.className = 'info';
            output.appendChild(span);
            output.scrollTop = output.scrollHeight;
        }

        window.runTest = async function() {
            log('=== SYSTEMATIC STATE SHAPE DISCOVERY ===\n');

            try {
                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                log('Creating session...', 'info');
                const session = await ort.InferenceSession.create('/models/tts/flow_lm_main_int8.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });
                log('Session created\n', 'success');

                // Start with current best guess
                const shapes = {
                    'state_0': [2, 1, 1000, 16, 64],
                    'state_1': [0],
                    'state_2': [1],
                    'state_3': [2, 1, 1000, 16, 64],
                    'state_4': [1],
                    'state_5': [1],
                    'state_6': [1],
                    'state_7': [1],
                    'state_8': [1],
                    'state_9': [1],
                    'state_10': [1],
                    'state_11': [1],
                    'state_12': [1],
                    'state_13': [1],
                    'state_14': [1],
                    'state_15': [1],
                    'state_16': [1],
                    'state_17': [1]
                };

                const dtypes = { 'state_2': 'int64' };
                for (let i = 0; i <= 17; i++) {
                    if (i !== 2) dtypes[] = 'float32';
                }

                log('Testing with current shape configuration:', 'info');
                Object.entries(shapes).forEach(([name, shape]) => {
                    log();
                });
                log('');

                const seqData = new Float32Array(1 * 1 * 32).fill(0);
                const sequence = new ort.Tensor('float32', seqData, [1, 1, 32]);

                const textData = new Float32Array(0);
                const textEmb = new ort.Tensor('float32', textData, [1, 0, 1024]);

                const stateInputs = {};
                for (let i = 0; i <= 17; i++) {
                    const name = ;
                    const shape = shapes[name];
                    const dtype = dtypes[name];
                    const size = shape.reduce((a, b) => a * b, 1);

                    if (size === 0) {
                        stateInputs[name] = new ort.Tensor(dtype, new (dtype === 'int64' ? BigInt64Array : Float32Array)(0), shape);
                    } else {
                        if (dtype === 'int64') {
                            stateInputs[name] = new ort.Tensor('int64', new BigInt64Array(size).fill(BigInt(0)), shape);
                        } else {
                            stateInputs[name] = new ort.Tensor('float32', new Float32Array(size).fill(0), shape);
                        }
                    }
                }

                log('Running model...', 'info');
                const inputs = {
                    sequence,
                    text_embeddings: textEmb,
                    ...stateInputs
                };

                const result = await session.run(inputs);

                log('âœ“ SUCCESS! All state shapes are correct!', 'success');
                log('\nOutput tensors:', 'success');
                Object.entries(result).forEach(([name, tensor]) => {
                    log();
                });

                log('\n=== FINAL DISCOVERED SHAPES ===', 'success');
                Object.entries(shapes).forEach(([name, shape]) => {
                    log();
                });

            } catch (err) {
                const msg = err.message;
                log(, 'error');
                log('\nPARSING ERROR MESSAGE:', 'info');

                if (msg.includes('Invalid rank')) {
                    const match = msg.match(/state_(\d+).*?Expected: (\d+)/);
                    if (match) {
                        const idx = match[1];
                        const rank = parseInt(match[2]);
                        log(, 'error');
                        log(, 'info');
                        log(, 'info');
                        log(, 'info');
                    }
                } else if (msg.includes('Got:') && msg.includes('Expected:')) {
                    const match = msg.match(/state_(\d+).*?Got: (\d+).*?Expected: (\d+)/);
                    if (match) {
                        const idx = match[1];
                        const got = parseInt(match[2]);
                        const expected = parseInt(match[3]);
                        log(, 'error');
                        log(, 'error');
                        log(, 'info');
                    }
                }
            }
        };

        // Auto-run on load
        setTimeout(() => runTest(), 500);
    </script>
</body>
</html>
