<!DOCTYPE html>
<html>
<head>
    <title>Test TTS with Fixed Shapes</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #f0f0f0; }
        pre { background: white; padding: 15px; border-radius: 4px; max-height: 600px; overflow-y: auto; }
    </style>
</head>
<body>
    <h1>Testing TTS with Fixed State Shapes</h1>
    <p>This test will attempt to generate speech to verify the shape fixes work correctly.</p>
    <pre id="output"></pre>

    <script type="module">
        import { PocketTTSClient } from '/tts/tts-client.js';

        function log(msg) {
            console.log(msg);
            const el = document.getElementById('output');
            el.textContent += msg + '\n';
            el.scrollTop = el.scrollHeight;
        }

        async function test() {
            try {
                log('=== TTS Shape Fix Test ===\n');
                log('Creating TTS client...');

                let ttsClient = null;
                let testComplete = false;
                let testError = null;

                const callbacks = {
                    onStatus: (status, state) => {
                        log(`[Status] ${status} (${state})`);
                    },
                    onReady: () => {
                        log('[Ready] TTS client ready for generation');
                    },
                    onAudioChunk: () => {
                        log('[Audio Chunk] Received audio chunk');
                    },
                    onMetrics: (metrics) => {
                        log(`[Metrics] ${JSON.stringify(metrics)}`);
                    },
                    onComplete: (url) => {
                        log('[Complete] TTS generation complete');
                        testComplete = true;
                    },
                    onVoicesLoaded: (voices, defaultVoice) => {
                        log(`[Voices] Loaded voices: ${voices.join(', ')}, default: ${defaultVoice}`);
                    }
                };

                ttsClient = new PocketTTSClient(callbacks);

                log('\nWaiting for TTS client initialization...');

                // Wait for ready
                let isReady = false;
                const readyPromise = new Promise(resolve => {
                    const origOnReady = callbacks.onReady;
                    callbacks.onReady = () => {
                        origOnReady?.();
                        isReady = true;
                        resolve();
                    };
                });

                await Promise.race([
                    readyPromise,
                    new Promise(resolve => setTimeout(resolve, 30000))
                ]);

                if (!isReady) {
                    log('Client initialization timed out');
                    return;
                }

                log('\n✓ TTS client initialized successfully!');
                log('\nNow testing actual generation with small text...');

                // Reset test flag
                testComplete = false;

                // Test generation
                const testText = 'hello';
                log(`Generating: "${testText}"`);
                ttsClient.generate(testText, 'default');

                // Wait for generation to complete
                await new Promise(resolve => {
                    const origOnComplete = callbacks.onComplete;
                    callbacks.onComplete = (url) => {
                        origOnComplete?.(url);
                        testComplete = true;
                        resolve();
                    };

                    // Timeout after 120 seconds
                    setTimeout(() => resolve(), 120000);
                });

                if (testComplete) {
                    log('\n✓ SUCCESS! TTS generation completed!');
                    log('The shape fixes are working correctly!');
                } else {
                    log('\nGeneration timeout or incomplete');
                }

            } catch (err) {
                log(`\nERROR: ${err.message}`);
                log(err.stack);
            }
        }

        test();
    </script>
</body>
</html>
