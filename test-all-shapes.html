<!DOCTYPE html>
<html>
<head>
    <title>Discover All State Shapes</title>
</head>
<body>
    <h1>Discovering all state shapes...</h1>
    <pre id="output" style="font-size: 11px; max-height: 900px; overflow-y: auto;"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = `https://cdn.jsdelivr.net/npm/onnxruntime-web@${ORT_VERSION}/dist/`;
        const output = document.getElementById('output');

        function log(msg) {
            console.log(msg);
            output.textContent += msg + '\n';
            output.scrollTop = output.scrollHeight;
        }

        async function test() {
            try {
                log('=== DISCOVERING ALL STATE SHAPES ===\n');

                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                log('Creating session...');
                const session = await ort.InferenceSession.create('/models/tts/flow_lm_main_int8.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                log('Session created\n');

                // Build state inputs incrementally, discovering shapes through errors
                const stateShapes = {};
                const stateTypes = {};

                // Known shapes from error messages
                stateShapes['state_0'] = [2, 1, 1000, 16, 64];
                stateTypes['state_0'] = 'float32';

                // state_1 is special - it has 0 elements
                stateShapes['state_1'] = [0];
                stateTypes['state_1'] = 'float32'; // Try float32 first

                // state_2-17 - try [1] as initial guess
                for (let i = 2; i <= 17; i++) {
                    stateShapes[`state_${i}`] = [1];
                    stateTypes[`state_${i}`] = 'float32';
                }

                // Try running model iteratively
                let attempt = 1;
                let success = false;

                while (!success && attempt < 20) {
                    log(`\n--- Attempt ${attempt} ---`);
                    log('Current state shapes:');
                    Object.entries(stateShapes).forEach(([name, shape]) => {
                        log(`  ${name}: [${shape.join(', ')}]`);
                    });

                    try {
                        // Create inputs
                        const seqData = new Float32Array(1 * 1 * 32).fill(0);
                        const sequence = new ort.Tensor('float32', seqData, [1, 1, 32]);

                        const textData = new Float32Array(0);
                        const textEmb = new ort.Tensor('float32', textData, [1, 0, 1024]);

                        // Create state tensors
                        const stateInputs = {};
                        for (let i = 0; i <= 17; i++) {
                            const name = `state_${i}`;
                            const shape = stateShapes[name];
                            const type = stateTypes[name];
                            const size = shape.reduce((a, b) => a * b, 1);

                            if (type === 'int64') {
                                const data = new BigInt64Array(size).fill(BigInt(0));
                                stateInputs[name] = new ort.Tensor('int64', data, shape);
                            } else {
                                const data = new Float32Array(size).fill(0);
                                stateInputs[name] = new ort.Tensor('float32', data, shape);
                            }
                        }

                        // Run model
                        const inputs = {
                            sequence,
                            text_embeddings: textEmb,
                            ...stateInputs
                        };

                        log('Running model...');
                        const result = await session.run(inputs);

                        log('SUCCESS! Model ran successfully!');
                        log('Output keys: ' + Object.keys(result).join(', '));
                        success = true;

                    } catch (err) {
                        const errMsg = err.message;
                        log('Error: ' + errMsg);

                        // Parse error to extract shape/type requirements
                        let foundIssue = false;

                        // Check for type mismatches - find which input needs int64
                        if (errMsg.includes('expected: (tensor(int64))')) {
                            // Try to identify which state by parsing error message
                            const inputMatch = errMsg.match(/input:\s*(\w+)/);
                            if (inputMatch) {
                                const stateName = inputMatch[1];
                                log(`  -> Changing ${stateName} from float32 to int64`);
                                stateTypes[stateName] = 'int64';
                                foundIssue = true;
                            } else {
                                // If we can't find which input, try changing the first state as int64
                                // Actually, let's try a different strategy - just try converting all states to int64
                                log(`  -> Cannot identify which state needs int64, converting state_1`);
                                stateTypes['state_1'] = 'int64';
                                foundIssue = true;
                            }
                        }

                        // Check for dimension mismatches
                        if (errMsg.includes('Got invalid dimensions')) {
                            const matches = errMsg.matchAll(/state_(\d+).*?Got: (\d+)/g);
                            for (const match of matches) {
                                const idx = match[1];
                                const got = parseInt(match[2]);
                                const name = `state_${idx}`;
                                log(`  -> state_${idx} has wrong size, got ${got}`);
                                foundIssue = true;
                            }
                        }

                        // Check for rank mismatches
                        if (errMsg.includes('Invalid rank')) {
                            const match = errMsg.match(/state_(\d+).*?Expected: (\d+)/);
                            if (match) {
                                const idx = match[1];
                                const expectedRank = parseInt(match[2]);
                                const name = `state_${idx}`;
                                log(`  -> state_${idx} expected rank ${expectedRank}`);
                                foundIssue = true;
                            }
                        }

                        if (!foundIssue) {
                            // Try incrementing state sizes
                            for (let i = 2; i <= 17; i++) {
                                const name = `state_${i}`;
                                const currentSize = stateShapes[name][0];
                                if (currentSize < 100) {
                                    stateShapes[name] = [currentSize + 1];
                                    log(`  -> Trying larger size for ${name}: [${currentSize + 1}]`);
                                    foundIssue = true;
                                    break;
                                }
                            }
                        }

                        if (!foundIssue) {
                            log('  -> Cannot parse error, stopping');
                            break;
                        }
                    }

                    attempt++;
                }

                log('\n\n=== FINAL DISCOVERED SHAPES ===\n');
                Object.entries(stateShapes).forEach(([name, shape]) => {
                    const type = stateTypes[name] || 'float32';
                    log(`${name}: [${shape.join(', ')}] (${type})`);
                });

            } catch (err) {
                log(`\nFATAL ERROR: ${err.message}`);
                log(err.stack);
            }
        }

        test();
    </script>
</body>
</html>
