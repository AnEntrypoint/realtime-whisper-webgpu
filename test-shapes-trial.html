<!DOCTYPE html>
<html>
<head>
    <title>Test Model Shapes by Trial</title>
</head>
<body>
    <h1>Testing model shapes...</h1>
    <pre id="output" style="font-size: 12px; max-height: 800px; overflow-y: auto;"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = `https://cdn.jsdelivr.net/npm/onnxruntime-web@${ORT_VERSION}/dist/`;
        const output = document.getElementById('output');

        function log(msg) {
            console.log(msg);
            output.textContent += msg + '\n';
            output.scrollTop = output.scrollHeight;
        }

        async function test() {
            try {
                log('Importing ONNX Runtime...');
                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                log('Creating session...');
                const session = await ort.InferenceSession.create('/models/tts/flow_lm_main_int8.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                log('Session created. Input names:');
                log(JSON.stringify(session.inputNames, null, 2));

                // Try to run with test tensors to see what shapes are expected
                log('\n=== ATTEMPTING MODEL RUN TO DISCOVER SHAPES ===\n');

                // Create test inputs with correct sizes
                const seqData = new Float32Array(1 * 1 * 32).fill(0);
                const sequence = new ort.Tensor('float32', seqData, [1, 1, 32]);

                const textData = new Float32Array(0);  // Empty array for [1, 0, 1024]
                const textEmb = new ort.Tensor('float32', textData, [1, 0, 1024]);

                // Create state tensors - we'll start with a guess and let errors guide us
                const stateInputs = {};
                const stateShapes = {};

                // Initial guess: all states are rank 1 with size 1
                log('Attempt 1: All states as [1]');
                for (let i = 0; i < 18; i++) {
                    const name = `state_${i}`;
                    stateInputs[name] = new ort.Tensor('float32', new Float32Array([0]).fill(0), [1]);
                    stateShapes[name] = [1];
                }

                try {
                    const inputs = {
                        sequence,
                        text_embeddings: textEmb,
                        ...stateInputs
                    };
                    const result = await session.run(inputs);
                    log('SUCCESS! All states as [1] worked!');
                    log('Output keys: ' + Object.keys(result).join(', '));
                } catch (err) {
                    log('Failed: ' + err.message);
                    log('');

                    // Parse error to see which state failed
                    const match = err.message.match(/state_(\d+)/);
                    if (match) {
                        const failedIdx = parseInt(match[1]);
                        log(`Failed on state_${failedIdx}`);
                    }

                    // Try with state_0 as 5D as mentioned in error
                    log('\nAttempt 2: state_0 as [2, 1, 1000, 16, 64], state_1 as []');

                    stateInputs['state_0'] = new ort.Tensor('float32', new Float32Array(2*1*1000*16*64).fill(0), [2, 1, 1000, 16, 64]);
                    stateShapes['state_0'] = [2, 1, 1000, 16, 64];

                    // state_1 needs 0 elements - try shape [0]
                    const state1Data = new Float32Array(0);
                    try {
                        stateInputs['state_1'] = new ort.Tensor('float32', state1Data, [0]);
                        stateShapes['state_1'] = [0];
                    } catch (e) {
                        log('Failed to create state_1 with [0]: ' + e.message);
                        stateInputs['state_1'] = new ort.Tensor('float32', new Float32Array([0]), [1]);
                        stateShapes['state_1'] = [1];
                    }

                    try {
                        const inputs = {
                            sequence,
                            text_embeddings: textEmb,
                            ...stateInputs
                        };
                        const result = await session.run(inputs);
                        log('SUCCESS with state_0 as 5D and state_1 as []!');
                        log('Output keys: ' + Object.keys(result).join(', '));
                    } catch (err2) {
                        log('Still failed: ' + err2.message);

                        // Try to extract dimension info from error
                        const dimMatches = err2.message.match(/state_(\d+).*?Expected: (\d+)/g);
                        if (dimMatches) {
                            log('\nExtracted state requirements from error:');
                            dimMatches.forEach(m => {
                                log('  ' + m);
                                const stateMatch = m.match(/state_(\d+)/);
                                const expectedMatch = m.match(/Expected: (\d+)/);
                                if (stateMatch && expectedMatch) {
                                    const idx = stateMatch[1];
                                    const expectedDim = expectedMatch[1];
                                    // Set dimension to the expected size
                                    const newShape = [expectedDim];
                                    if (expectedDim === 0) {
                                        stateInputs[`state_${idx}`] = new ort.Tensor('float32', new Float32Array(0), []);
                                        stateShapes[`state_${idx}`] = [];
                                    } else {
                                        stateInputs[`state_${idx}`] = new ort.Tensor('float32', new Float32Array(expectedDim).fill(0), newShape);
                                        stateShapes[`state_${idx}`] = newShape;
                                    }
                                }
                            });

                            // Try again with updated shapes
                            log('\nAttempt 3: With corrected shapes from error...');
                            try {
                                const inputs = {
                                    sequence,
                                    text_embeddings: textEmb,
                                    ...stateInputs
                                };
                                const result = await session.run(inputs);
                                log('SUCCESS!');
                                log('Output keys: ' + Object.keys(result).join(', '));
                            } catch (err3) {
                                log('Attempt 3 failed: ' + err3.message);
                            }
                        }
                    }
                }

                // Final results
                log('\n=== DISCOVERED SHAPES ===');
                Object.entries(stateShapes).forEach(([name, shape]) => {
                    log(`${name}: [${shape.join(', ')}]`);
                });

            } catch (err) {
                log(`ERROR: ${err.message}`);
                log(err.stack);
            }
        }

        test();
    </script>
</body>
</html>
