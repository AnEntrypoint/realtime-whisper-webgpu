<!DOCTYPE html>
<html>
<head>
    <title>Find int64 State</title>
</head>
<body>
    <h1>Finding which state is int64...</h1>
    <pre id="output"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = `https://cdn.jsdelivr.net/npm/onnxruntime-web@${ORT_VERSION}/dist/`;

        function log(msg) {
            console.log(msg);
            document.getElementById('output').textContent += msg + '\n';
        }

        async function test() {
            try {
                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                const session = await ort.InferenceSession.create('/models/tts/flow_lm_main_int8.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                log('Testing which state is int64...\n');

                // Test each state as int64
                for (let testIdx = 0; testIdx <= 17; testIdx++) {
                    log(`Testing with state_${testIdx} as int64...`);

                    const seqData = new Float32Array(1 * 1 * 32).fill(0);
                    const sequence = new ort.Tensor('float32', seqData, [1, 1, 32]);

                    const textData = new Float32Array(0);
                    const textEmb = new ort.Tensor('float32', textData, [1, 0, 1024]);

                    const stateInputs = {};

                    for (let i = 0; i <= 17; i++) {
                        const name = `state_${i}`;
                        const isInt64 = i === testIdx;

                        let shape, data;

                        if (name === 'state_0') {
                            shape = [2, 1, 1000, 16, 64];
                        } else if (name === 'state_1') {
                            shape = [0];
                        } else {
                            shape = [1];
                        }

                        const size = shape.reduce((a, b) => a * b, 1);

                        if (size === 0) {
                            // Empty tensor - use empty array
                            if (isInt64) {
                                const int64Data = new BigInt64Array(0);
                                stateInputs[name] = new ort.Tensor('int64', int64Data, shape);
                            } else {
                                const float32Data = new Float32Array(0);
                                stateInputs[name] = new ort.Tensor('float32', float32Data, shape);
                            }
                        } else {
                            if (isInt64) {
                                const int64Data = new BigInt64Array(size).fill(BigInt(0));
                                stateInputs[name] = new ort.Tensor('int64', int64Data, shape);
                            } else {
                                const float32Data = new Float32Array(size).fill(0);
                                stateInputs[name] = new ort.Tensor('float32', float32Data, shape);
                            }
                        }
                    }

                    try {
                        const inputs = {
                            sequence,
                            text_embeddings: textEmb,
                            ...stateInputs
                        };

                        const result = await session.run(inputs);
                        log(`SUCCESS! state_${testIdx} is the int64 state!`);
                        log(`Outputs: ${Object.keys(result).join(', ')}`);
                        break;

                    } catch (err) {
                        const msg = err.message;
                        if (msg.includes('Unexpected input data type') && msg.includes('expected: (tensor(int64))')) {
                            log(`  Still needs int64 adjustment...`);
                        } else {
                            log(`  Error: ${msg.substring(0, 100)}`);
                        }
                    }
                }

            } catch (err) {
                log(`Error: ${err.message}`);
            }
        }

        test();
    </script>
</body>
</html>
