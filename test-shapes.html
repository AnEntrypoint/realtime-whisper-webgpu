<!DOCTYPE html>
<html>
<head>
    <title>Test Model Shapes</title>
</head>
<body>
    <h1>Loading model...</h1>
    <pre id="output"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = `https://cdn.jsdelivr.net/npm/onnxruntime-web@${ORT_VERSION}/dist/`;
        const output = document.getElementById('output');

        function log(msg) {
            console.log(msg);
            output.textContent += msg + '\n';
        }

        async function test() {
            try {
                log('Importing ONNX Runtime...');
                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;
                log('ONNX Runtime imported successfully');

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                log('\nCreating session for: /models/tts/flow_lm_main_int8.onnx');
                const modelPath = '/models/tts/flow_lm_main_int8.onnx';
                const session = await ort.InferenceSession.create(modelPath, {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                log('Session created successfully!\n');

                log('Input names: ' + JSON.stringify(session.inputNames));
                log('Output names: ' + JSON.stringify(session.outputNames));
                log('Input metadata type: ' + typeof session.inputMetadata);
                log('Output metadata type: ' + typeof session.outputMetadata);
                log('');

                log('=== STATE INPUTS ===');
                const stateShapeMap = {};

                // Check if metadata is available
                const hasInputMetadata = session.inputMetadata !== undefined;
                log('Has inputMetadata: ' + hasInputMetadata);

                if (hasInputMetadata) {
                    session.inputNames.forEach(name => {
                        const meta = session.inputMetadata[name];
                        if (!meta) {
                            log(`WARNING: No metadata for ${name}`);
                        } else {
                            const shape = Array.isArray(meta.dims) ? Array.from(meta.dims) : meta.dims;
                            log(`${name}: shape=${JSON.stringify(shape)}, type=${meta.type}`);

                            if (name.startsWith('state_')) {
                                stateShapeMap[name] = shape;
                            }
                        }
                    });
                } else {
                    log('ERROR: session.inputMetadata is not available');
                    log('Session properties: ' + Object.keys(session).join(', '));
                    log('Trying alternative approach...');

                    // Try using alternative properties
                    if (session.input) {
                        log('Found session.input: ' + JSON.stringify(session.input));
                    }
                    if (session.inputs) {
                        log('Found session.inputs: ' + JSON.stringify(session.inputs));
                    }
                }

                log('\n=== ALL INPUTS ===');
                if (hasInputMetadata) {
                    session.inputNames.forEach(name => {
                        const meta = session.inputMetadata[name];
                        const shape = Array.isArray(meta.dims) ? Array.from(meta.dims) : meta.dims;
                        log(`${name}: [${shape.join(', ')}]`);
                    });
                } else {
                    log('Cannot display inputs - no metadata available');
                }

                log('\n=== ALL OUTPUTS ===');
                const hasOutputMetadata = session.outputMetadata !== undefined;
                if (hasOutputMetadata) {
                    session.outputNames.forEach(name => {
                        const meta = session.outputMetadata[name];
                        const shape = Array.isArray(meta.dims) ? Array.from(meta.dims) : meta.dims;
                        log(`${name}: [${shape.join(', ')}]`);
                    });
                } else {
                    log('Cannot display outputs - no metadata available');
                }

                log('\n=== GENERATED CODE FOR tts-client.js ===');
                log('const stateShapeMap = {');
                Object.entries(stateShapeMap).forEach(([name, dims]) => {
                    log(`    "${name}": [${dims.join(', ')}],`);
                });
                log('};');

            } catch (err) {
                log(`\nERROR: ${err.message}`);
                log(err.stack);
            }
        }

        test();
    </script>
</body>
</html>
